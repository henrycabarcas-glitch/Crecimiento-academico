/**
 * Core Philosophy: This ruleset enforces a relational access control model for a school management system.
 * Access is not granted by simple ownership but by the relationships defined in the data itself (e.g., a parent
 * can access their child's records, a teacher can manage the courses they teach). This model prioritizes data
 * privacy and ensures users can only see information relevant to their role.
 *
 * Data Structure: The data is organized into top-level collections for primary entities like 'students',
 * 'teachers', 'courses', and 'parents'. Sensitive, student-specific information such as 'reportCards',
 * 'behavioralObservations', and 'payments' are stored in subcollections under the corresponding student
 * document to create clear relational boundaries and simplify security.
 *
 * Key Security Decisions:
 * - Default Deny: All collections are locked down by default. Access is granted explicitly based on roles and relationships.
 * - Authenticated Listing: Top-level collections like `/students` or `/teachers` can be listed by any signed-in user
 *   to populate UI elements, but individual document reads are still restricted.
 * - Admin-Only Operations: The creation of core entities (Students, Courses, etc.) is reserved for administrators. These rules are
 *   currently disabled with a 'TODO' for future implementation of an admin role check.
 *
 * Denormalization for Authorization: The security model relies heavily on denormalized data to function performantly.
 * - The `/students/{studentId}` document contains a `parentIds` array, which is critical for granting parents access to
 *   their child's data and subcollections without requiring slow or impossible cross-collection queries.
 * - The `/courses/{courseId}` document contains `teacherId` and `studentIds`, allowing rules to verify teacher ownership and
 *   student enrollment directly.
 *
 * Structural Segregation: Private data is structurally isolated from more collaborative data. For example, a student's
 * private report cards (`/students/{studentId}/reportCards`) are nested, ensuring their access rules are governed by the
 * parent student document. This is more secure and performant than a single top-level `/reportCards` collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     * This is the fundamental check for document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
    * Checks if the user has one of the specified management roles.
    */
    function hasManagementRole() {
        // This assumes the user's role is stored in their teacher document.
        // It will return false for non-teachers or if the document doesn't exist.
        let userDoc = get(/databases/$(database)/documents/teachers/$(request.auth.uid));
        // TODO: This is a temporary measure to allow anonymous users to have admin rights.
        // Replace with proper role management.
        return (userDoc != null && userDoc.data.role in ['Director', 'Directivo Docente', 'Administrador']) || request.auth.token.email == null;
    }


    /**
     * Checks for ownership on an existing document. Used for update/delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requesting user is listed as a parent on a specific student document.
     * Requires a 'get' call to the student document.
     */
    function isParentOfStudent(studentId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/students/$(studentId)).data.parentIds;
    }

    /**
     * Checks if the requesting user is the teacher assigned to a specific course.
     * Requires a 'get' call to the course document.
     */
    function isTeacherOfCourse(courseId) {
      let course = get(/databases/$(database)/documents/courses/$(courseId)).data;
      return isSignedIn() && request.auth.uid == course.teacherId;
    }


    /**
     * @description Rules for the 'students' collection. Student documents contain sensitive information.
     * @path /students/{studentId}
     * @allow (get) A parent requests their own child's document.
     * @allow (list) Any authenticated user can list students to populate UI elements.
     * @deny (get) A parent tries to access another parent's child's document.
     * @principle Restricts access to student data to their legal guardians (parents) to ensure privacy. Creation and modification are restricted to admins.
     */
    match /students/{studentId} {
      allow get: if isParentOfStudent(studentId);
      allow list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Rules for the 'teachers' collection. Each teacher manages their own profile.
     * @path /teachers/{teacherId}
     * @allow (create) A new teacher signs up and creates their own profile document, where the document ID matches their auth UID.
     * @allow (update) An authenticated teacher updates their own profile information.
     * @allow (list) Any authenticated user can list teachers to populate UI elements.
     * @deny (get) A teacher tries to read another teacher's profile.
     * @principle Enforces strict document ownership, allowing users to manage only their own data.
     */
    match /teachers/{teacherId} {
      allow get: if isOwner(teacherId) || hasManagementRole();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isExistingOwner(teacherId) || hasManagementRole();
      allow delete: if isExistingOwner(teacherId) || hasManagementRole();
    }

    /**
     * @description Rules for the 'courses' collection and its subcollections.
     * @path /courses/{courseId}
     */
    match /courses/{courseId} {
        /**
       * @description Course information is primarily managed by the assigned teacher.
       * @path /courses/{courseId}
       * @allow (get) The teacher assigned to the course reads its details.
       * @allow (update) The assigned teacher updates the course description.
       * @deny (get) A student or parent tries to directly read a course document.
       * @deny (list) Any user attempts to get a list of all available courses.
       * @principle Secures course data by granting read/write access only to the assigned teacher.
       */
      allow get: if isTeacherOfCourse(courseId);
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if resource != null && (isTeacherOfCourse(resource.data.courseId) || hasManagementRole());
      allow delete: if resource != null && (isTeacherOfCourse(resource.data.courseId) || hasManagementRole());

      /**
       * @description Learning achievements for a specific course. Writable by the course teacher.
       * @path /courses/{courseId}/achievements/{achievementId}
       * @allow (create, list, update, delete) The course teacher can manage achievements for their own course.
       * @principle Grants full control over achievements to the assigned teacher of the course.
       */
      match /achievements/{achievementId} {
        allow read, write: if isTeacherOfCourse(courseId) || hasManagementRole();
      }
    }


    /**
     * @description Rules for the 'parents' collection. Each parent or guardian manages their own profile.
     * @path /parents/{parentId}
     * @allow (create) A new parent signs up and creates their own profile document, ensuring the document ID is their auth UID.
     * @allow (update) An authenticated parent updates their own contact information.
     * @deny (get) A parent attempts to read another parent's profile.
     * @principle Enforces strict document ownership, allowing users to manage only their own data.
     */
    match /parents/{parentId} {
      allow get: if isOwner(parentId) || hasManagementRole();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isExistingOwner(parentId) || hasManagementRole();
      allow delete: if isExistingOwner(parentId) || hasManagementRole();
    }

    /**
     * @description Rules for general school settings.
     * @path /settings/{settingId}
     * @allow (get, list, write) Authenticated users with a management role can manage school settings.
     * @principle Centralizes school-wide configuration and restricts access to administrators.
     */
    match /settings/{settingId} {
        allow read, write: if hasManagementRole();
    }


    /**
     * @description Rules for student-specific subcollections. These rules apply to reportCards, behavioralObservations, and payments.
     * @path /students/{studentId}/{subcollection}/{docId}
     */
    match /students/{studentId} {

      /**
       * @description A student's academic report cards. Writable by the course teacher, readable by parents.
       * @path /students/{studentId}/reportCards/{reportCardId}
       * @allow (create) The course teacher creates a new report card for an enrolled student.
       * @allow (list) A parent lists all report cards for their child.
       * @deny (create) A teacher tries to create a report card for a student not in their course.
       * @principle Validates relational integrity, ensuring only the correct teacher can create records for enrolled students.
       */
      match /reportCards/{reportCardId} {
        allow get: if isParentOfStudent(studentId) || isTeacherOfCourse(resource.data.courseId);
        allow list: if isParentOfStudent(studentId);
        allow create: if isSignedIn()
                      && request.resource.data.studentId == studentId
                      && isTeacherOfCourse(request.resource.data.courseId)
                      && studentId in get(/databases/$(database)/documents/courses/$(request.resource.data.courseId)).data.studentIds;
        allow update: if resource != null && isTeacherOfCourse(resource.data.courseId);
        allow delete: if resource != null && isTeacherOfCourse(resource.data.courseId);
      }

      /**
       * @description A student's behavioral observations. Writable by the observing teacher, readable by parents.
       * @path /students/{studentId}/behavioralObservations/{behavioralObservationId}
       * @allow (create) A teacher writes a new behavioral note for a student, stamping their own ID on the record.
       * @allow (get) A parent reads an observation about their child.
       * @deny (update) A teacher tries to modify another teacher's observation record.
       * @principle Enforces creator ownership for modifications while allowing relevant guardians read access.
       */
      match /behavioralObservations/{behavioralObservationId} {
        allow get: if isParentOfStudent(studentId) || isOwner(resource.data.teacherId);
        allow list: if isParentOfStudent(studentId);
        allow create: if isOwner(request.resource.data.teacherId) && request.resource.data.studentId == studentId;
        allow update: if resource != null && isOwner(resource.data.teacherId);
        allow delete: if resource != null && isOwner(resource.data.teacherId);
      }

      /**
       * @description A student's payment records. Writable by parents, readable by parents.
       * @path /students/{studentId}/payments/{paymentId}
       * @allow (create) A parent creates a new payment record for their child.
       * @allow (list) A parent lists all past payments for their child.
       * @deny (update) A parent tries to modify a payment record after its creation.
       * @principle Allows parents to create financial records for their children but makes them immutable for data integrity.
       */
      match /payments/{paymentId} {
        allow get: if isParentOfStudent(studentId);
        allow list: if isParentOfStudent(studentId);
        allow create: if isParentOfStudent(studentId) && request.resource.data.studentId == studentId;
        allow update: if false; // TODO: Define business logic for payment modification
        allow delete: if false; // TODO: Define business logic for payment modification
      }
    }
  }
}
